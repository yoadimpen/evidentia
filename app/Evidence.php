<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Evidence extends Model
{

    protected $table="evidences";

    protected $fillable = [
        'id', 'title', 'description', 'hours', 'user_id', 'comittee_id', 'points_to', 'status', 'stamp', 'rand'
    ];

    public function proofs()
    {
        return $this->hasMany('App\Proof');
    }

    public function user()
    {
        return $this->belongsTo('App\User');
    }

    public function comittee()
    {
        return $this->belongsTo('App\Comittee');
    }

    public function reason_rejection()
    {
        return $this->hasOne('App\ReasonRejection');
    }

    /**
     * @return mixed
     * Evidence Flow
     */

    // lista las evidencias ANTERIORES a esta
    public function previous_evidences()
    {
        $evidence_previous = Evidence::find($this->points_to);

        // si es null, es que el flujo solo contiene una evidencia
        if($evidence_previous == null){
            $evidences = collect();
            $evidences->push($this);
            return $evidences;
        }else{
            return $this->previous_evidences_p($evidence_previous,collect());
        }

    }

    private function previous_evidences_p($evidence,$collection)
    {

        $collection->push($evidence);

        if($evidence->points_to == null){
            return $collection;
        }else{
            $evidence_previous = Evidence::find($evidence->points_to);
            return $this->previous_evidences_p($evidence_previous,$collection);
        }
    }

    // lista las evidendes POSTERIORES a esta
    public function later_evidences()
    {
        $points_me = Evidence::where('points_to',$this->id)->first();

        // si es null, es que el flujo solo contiene una evidencia
        if($points_me == null){
            $evidences = collect();
            $evidences->push($this);
            return $evidences;
        }else{
            return $this->later_evidences_p($points_me,collect());
        }

    }

    private function later_evidences_p($evidence,$collection)
    {
        $collection->push($evidence);

        if($evidence->last)
            return $collection;
        else {
            $points_me = Evidence::where('points_to',$evidence->id)->first();
            return $this->later_evidences_p($points_me,$collection);
        }
    }

    // lista el flujo total de ediciones de evidencias, desde la primera ediciÃ³n a la Ãºltima
    public function flow_evidences(){
        $previous_evidences = $this->previous_evidences();
        $later_evidences = $this->later_evidences();
        return $previous_evidences->concat($later_evidences)->push($this)->unique()->sortByDesc('created_at');
    }

    // obtiene la evidencia que va a la cabeza del flujo de ediciones
    public function find_header_evidence()
    {
        return $this->find_header_evidence_p($this);
    }

    private function find_header_evidence_p($evidence)
    {
        if($evidence->last)
            return $evidence;
        else {
            $points_me = Evidence::where('points_to',$evidence->id)->first();
            return $this->find_header_evidence_p($points_me);
        }
    }

    public static function evidences_not_draft() {
        return Evidence::where('status','!=', 'DRAFT')->orderByDesc('updated_at')->get();
    }

    public static function evidences_draft() {
        return Evidence::where('status','=', 'DRAFT')->where('points_to','=',null)->orderByDesc('updated_at')->get();
    }

    public static function evidences_pending() {
        return Evidence::where('status','=', 'PENDING')->orderByDesc('updated_at')->get();
    }

    public static function evidences_accepted() {
        return Evidence::where('status','=', 'ACCEPTED')->orderByDesc('updated_at')->get();
    }

    public static function evidences_rejected() {
        return Evidence::where('status','=', 'ACCEPTED')->orderByDesc('updated_at')->get();
    }

    public function integrity()
    {
        return $this->stamp == \Stamp::get_stamp_evidence($this);
    }

    // evidencias por comitÃ©
    public static function evidences_presidencia() {
        return Evidence::where('comittee_id','=', '1')->orderByDesc('updated_at')->get();
    }

    public static function evidences_secretaria() {
        return Evidence::where('comittee_id','=', '2')->orderByDesc('updated_at')->get();
    }

    public static function evidences_programa() {
        return Evidence::where('comittee_id','=', '3')->orderByDesc('updated_at')->get();
    }

    public static function evidences_igualdad() {
        return Evidence::where('comittee_id','=', '4')->orderByDesc('updated_at')->get();
    }

    public static function evidences_sostenibilidad() {
        return Evidence::where('comittee_id','=', '5')->orderByDesc('updated_at')->get();
    }

    public static function evidences_finanzas() {
        return Evidence::where('comittee_id','=', '6')->orderByDesc('updated_at')->get();
    }

    public static function evidences_logistica() {
        return Evidence::where('comittee_id','=', '7')->orderByDesc('updated_at')->get();
    }

    public static function evidences_comunicacion() {
        return Evidence::where('comittee_id','=', '8')->orderByDesc('updated_at')->get();
    }

}
